# 毕设 - 拼图游戏

vue-admin

template



数据结构

html+ css+ js

网络

vue基础



## 一.搭建项目

### 1.1.创建puzzle项目

本项目先做移动端,  若后期有精力优化PC端页面



- ```js
  vue create puzzle
  ```

### 1.2.引入vuetify

- ```js
  cd puzzle
  vue add vuetify
  ```

### 1.3.Github托管

创建新的仓库

远程连接git

```js
git remote add origin git @github.com:slimmerYu/Jigsaw-puzzle.git
git push -u origin master

git add .
git commit -m "文字说明"
git push || git push -u origin master
```

#### 遇到的问题

- 在项目后期有将近一个月没有更新远程仓库, 再次push项目时总是失败

- 原因是推送文件太大, 分析是缓存不够或网络不好

- 解决方法: 在 .git目录下面修改生成的config文件增加如下：

  ```html
  [http]  
  
  postBuffer = 1048576000
  ```



- 搭建登录页面

- 调用接口


- ```js
  //axios全局配置
  axios.defaults.baseURL = 'http://nas.wpengsen.cn:8989'
  axios.defaults.timeout = 5000
  ```

## 二.axios实例与模块封装

### 2.1.axios实例

```js
// const instance = axios.create({
//   baseURL: '',
//   timeout: 5000
// })
// instance({
//   url:''
// })
```

### 2.2.封装axios

- 封装原因
  - 防止axios框架出现问题,需要更换别的 框架
  - 若框架 出现问题,只需要在封装文件request.js中更改引用与使用框架的代码,返回promise,其他使用的地方无需更改

- 创建文件夹network

- 创建文件request.js

- ```js
  import axios from 'axios'
  export function request(config) {
        // 1.创建axios实例
    const instance = axios.create({
      baseURL: 'http://nas.wpengsen.cn:8989',
      timeout: 5000
    })
  
    // 发送真正的网络请求
    return instance(config)
    // instance(config)
    // .then(res => {
    //   resolve(res)
    // })
    // .catch(err => {
    //   reject(err)
    // })
    // })
  }
  
  ```

- 由于 axios本身返回的就是promise,所以直接返回即可,不需要再包装一个promise(即后面注释部分)

- 在main.js中调用

  - ```js
    // 5.封装request模块
    import {request} from "./network/request"
    request({
      url: '/sysUser'
    }).then(res => {
      console.log(res);
    }).catch(err => {
      console.log(err);
    })
    ```

  - 

### 2.3.axios拦截器

四个拦截:请求成功,请求失败,响应成功,响应失败

#### 2.3.1.请求拦截

```js
 instance.interceptors.request.use(config => {
    console.log(config);
    return config;//拦截下来做出处理后,必须返回,不然内部在发送请求时就没有config了
  } ,err => {
    console.log(err);
  })
```

作用:

- config中的一些信息不符合服务器要求,需进行一些变化
- 每次发送网络请求时都希望在界面中显示一个请求图标
- 某些网络请求(比如登录token),是必须携带一些特殊的信息

#### 2.3.2.响应拦截

```js
instance.interceptors.response.use(res => {
    console.log(res);
    return res.data;//处理完后返回data,data才是需要的
  }, err  => {
    console.log(err);
  })
```

## 三.划分目录结构

- src

  - assets

    - css[样式文件夹]
    - img[图片文件夹]

  - components

    - common[完全公共的组件,下一个项目也可以使用]
    - content[与当前项目业务相关的组件]

  - common[公共js文件]

    - const.js
    - utils.js[公共方法]
    - mixin.js[混入]

  - network[网络相关调用接口封装]

  - views[视图页面]

  - router[路由]

  - store[状态管理vuex]

  - plugins[插件]

    - vuetify.js

  - App.vue

  - main.js

    

## 四.css样式引入

```css
<style>
	@import "@/assets/css/.css"
</style>
```



## 五.vue.config

别名设置

```js
module.exports = {
    chainWebpack:(config)=>{
    config.resolve.alias
        .set('@',resolve('./src'))
        .set('components',resolve('./src/components'))
        .set('views',resolve('./src/views'))
        .set('assets',resolve('./src/assets'))
        .set('network',resolve('./src/network'))
        .set('common',resolve('./src/common'))
    //set第一个参数：设置的别名，第二个参数：设置的路径

  }
}
```



## 六.vueX-状态管理工具

储存多个组件共享的状态,数据;

为什么用vueX, 因为它是响应式的,放在统一的地方进行保存和管理

- 需要多个组件间共享的状态
  - 用户登录状态,头像,名称,地理位置
  - 商品收藏,购物车商品

### 6.1.创建对象

- index.js

```js
const store = new Vuex.Store({
    state:{
        counter:100
    },//用于保存状态
    mutations:{
        //方法
        increment() {//默认参数state
            state.counter++,
                students: [
                    {id: 1, name: 'aa', age: 18}
                ]
        },
        decrement() {
            state.counter--
        }
    },//devtools安装在浏览器中,跟踪记录每一次修改状态,便于找出出问题的组件
    actions:{},//异步操作,发送网络请求
    getters:{
        greaterAgeCount: state => {
            return state.students.filter( s => s.age >= 20).length
        }
    },//类似计算属性
    modules:{}//划分模块,针对模块再做操作
})
```

### 6.2使用状态

- .vue文件

- ```html
  {{$store.state.counter}}
  <button @click="add"></button>
  
  methods:{
  	add() {
  		this.$store.commit('increment')
  	}
  }
  ```

### 6.3.state单一状态树

- single source of Truth 单一数据源
- 只创建一个store, 调用时只调用一个store
- 没有必要创建多个, 此处没有安全性的问题

### 6.4.Getters基本使用

- 有时候,需要从 store中获取一些state变异后的 状态

- getters可作为另一个getters的参数

  - ```js
    getters: {
        greaterAgeCount: state => {
                return state.students.filter( s => s.age >= 20).length
        },
        AgeName(getters):(state,getters) => getters.greaterAgeCount.name
    }
    ```

- getters获取组件给的参数

  - ```js
    getters: {
        moreAgeStu: state => {
            return function (age) {
                return state.students.filter( s => s.age > age)
            }
        }
    }
    ```

### 6.5.mutation

- Vuex的store状态的更新唯一方式 : 提交 mutation
- mutation主要包括两部分
  - 字符串的**事件类型( type )**
  - 一个**回调函数 ( handler )**,该回调函数的第一个参数就是state

#### 6.5.1.mutation的基本使用

- mutation的定义方式

  - ```js
    mutations: {
        函数名([参数]) {
            函数体
    }
    ```

- 通过mutation更新

  - ```js
    methods: {
        函数名() {
            this.$store.commit('mutations的函数名')
        }
    }
    ```

#### 6.5.2.带参数 的 mutation

- mutation接收组件参数

  - 参数被称为是mutation的载荷( payload )

  - ```js
    mutations: {
        incrementCount(state, count) {
            state.count += count
        }
    }
    ```

- 组件向mutation 传递参数

  - ```js
    methods: {
        addCount(count) {
            this.$store.commit('incrementCount', count)
        }
    }
    //参数可以是任意类型,比如一个对象,mutation获取参数后将 对象push进数组
    ```

  - 

#### 6.5.3.mutation的提交风格

- 普通的提交风格, 见上述代码

- 特殊的提交风格

  - ```js
    methods: {
        addCount(count) {
            this.$store.commit({
        		type:'mutation中的函数名[即mutation的第一个部分,事件类型]',
        		count,
                [多个参数...]
    		})
        }
    }
    ```

  - ```js
    mutations: {
        incrementCount(state,payload) {
            state.count += payload.count
        }
    }
    ```

#### 6.5.4.mutation的响应规则

- Vuex对应的规则
  - **提前**在store中初始化好所需的属性
    - 这些属性都会被加入到响应式系统中, 而响应式系统会监听属性变化, 当属性发生变化时, 会通知所有界面中用到该属性的地方, 让界面发生刷新
  - 当给state中的对象添加**新属性时(后加的,没有被提前初始化),**使用下面的方式
    - 方式一: 使用Vue.set( obj, 'newProp' ,123)
    - 方式二: 用新对象给旧对象赋值
      - state.objName = {...state.objName, 'key':value}
  - 删除一个属性
    - Vue.delete(state.objectName, 'propName')

#### 6.5.6.mutation的类型常量

- mutations-types.js

  - ```js
    export const upper函数名 = '函数名'
    ```

- index.js

  - ```js
    mutatiions: {
        [upper函数名](state) {
            函数体
        }
    }
    ```

- .vue

  - ```js
    methods:{
        函数名() {
            this.$store.commit(upper函数名)
        }
    }
    ```

  - 

#### 6.5.7.mutation同步函数

- 使用devtools帮助跟踪,若mutation中执行异步函数, 工具无法正确跟踪, 信息错误

### 6.6.action,替代mutation执行异步操作

- 基本使用

- 默认属性context :上下文,相当于store

  - ```js
    actions:{
        aUpdateInfo(context,payload) {
            setTimeout(() => {
                context.commit('mutation中的函数名')
            },1000)
        }
    }
    ```

  - ```js
    methods:{
        updateInfo() {
            this.$store.dispatch('aUpdateInfo',{
            	mes:'',
                success: ()=>{}
            })
        }
    }
    ```

  - 

### 6.7.modules

- 模块区分, 防止state过于臃肿

- ```js
  const moduleA = {
      state: {},
      multations: {},
      actions: {
          aFunc(context) {//此处context不再表示store,而是moduleA
              setTimeout(() => {
                   context.commit('multationFunc')
              },1000)
          }
      },
      getters: {
          //在模块中可以有第三个参数rootState
          moduleGetter(state,getters,rootState) {
              return getters.getter + rootState.state
          }
      }
  }
  const moduleB = {
      state: {},
      multations: {},
      actions: {},
      getters: {}
  }
  modules: {
      a: moduleA,
      b: moduleB
  }
  ```

- ```js
  $store.state.a.状态名
  提交mutation方式不变
  getter使用方式不变
  ```

- 

## 七.实现登录跳转

### 7.1.登录业务流程

- 在登录页输入手机号与密码

- 调用后台接口进行验证

- ```js
  // import axios from 'axios'
  import qs from 'qs'
  export default {
    name: 'Login',
  
    components: {
    },
    data: () => ({ 
      show: false,//密码显示或显示*
      valid: true,
      success: false,//登录成功
      snackbar: false,//控制提示框显示与隐藏
      loading: false,//控制登录按钮的加载动画
      rules: {
        required: value => !!value || 'Required.',
        moblie: (value) => {
          const pattern = /^[1]([3-9])[0-9]{9}$/;
          return pattern.test(value) || 'Please input the correct mobile phone number'
        }
      },
      user: {
        tel: '13931112192',//用户手机号
        pwd: '123456789'//用户密码
      },
      result:[]//用户数据
    }),
    methods: {
      login() {
        if(this.$refs.form.validate()){//将验证所有输入并返回它们是否都有效
          
          // console.log(this.user.tel,this.user.pwd);
          this.$axios.post('http://47.94.84.88:8989/login',qs.stringify({tel:this.user.tel,password:this.user.pwd}))
          .then(res=>{
              console.log(res)
              if (res.data.code === 200) {
                // console.log(res.data.message);
                // 用于判断提示框
                this.success = true
                // 用于登录按钮加载动画
                this.loading = true
                // 跳转页面
                setTimeout(() => {
                  this.$router.push({path: "/"})
                }, 1000);
  
                // localStorage.setItem('token',res.data.data)
                  // 将登录名使用vuex传递到Home页面
              this.$store.commit('handleUserName',res.data.data.tel);
              }else {
                this.success = false
                console.log('手机号或密码错误');
              }
          })
        }
      }
    },
  };
  </script>
  ```


### 手机验证码登录

#### 页面搭建

- 手机输入框, 

  - 手机格式验证, 

  - 不为空验证 ,

  -  获取验证码按钮, 

    - 点击通过手机号请求验证码

    - 按钮变为动态 '60s后再次发送'

    - 计时器结束重新显示请求验证码按钮

      - ```js
        validateBtn(){
           //倒计时
           let time = 60;
           let timer = setInterval(() => {
           if(time == 0) {
            clearInterval(timer);
            this.disabled = false;
            this.btnTitle = "获取验证码";
           } else {
            this.btnTitle =time + '秒后重试';
            this.disabled = true;
            time--
           }
          },1000)
        },
            handleLogin() {
            //点击发送
            this.errors = {};
            this.$axios.post('/api/posts/sms_back',{
                phone:this.phone,
                code:this.verifyCode
            }).then(res => {
                console.log(res);
                localStorage.setItem('ele_login',true)
                this.$router.push('/')
            }).catch(error =>{
                //返回错误信息
                this.errors ={
                code:error.response.data.msg
            }
           })
        }
        ```

      - 

- 验证码输入框, 不为空验证

- 通过验证后,根据后台的响应状态跳转到项目主页



- 登录业务相关技术点
  - 通过token方式维持状态

### 7.2.登录- token原理分析

- 客户端与服务器存在跨域问题
  - 登录页输入用户名和密码进行登录
  - 服务器验证通过之后生成该用户的token并返回
  - 客户端存储该token,
  - 客户端后续的所有请求都携带该token发送
  - 服务器验证token是否通过,根据不同的token返回不同的数据

### 7.3.登录退出的具体实现

#### 7.3.1.页面布局结构

#### 7.3.2.渲染login组件并实现路由

#### 7.3.3.绘制表单区域

#### 7.3.4.实现表单数据绑定

- vuetify自带的validate()方法验证输入是否有效
- 在判断有效后使用axios调用接口,使用qs传递将参数格式化,使用post传递参数
- 使用promise的.then方法获取返回的数据, 判断返回的code值 ===200,登录成功,跳转至home页面
- 在vuex中, 使用localStorage.setItem保存登录的用户手机号,
- 在navbar使用vuex中保存的数据信息



### qs 的使用

- qs是一个url参数转化（parse和stringify）的js库

- 使用qs传递参数实现登录验证

  - ```js
    this.$axios.post('http://47.94.84.88:8989/login',qs.stringify({tel:this.user.tel,password:this.user.pwd}))
            .then(res=>{
                console.log(res)
                if (res.data.code === 200) {
                  // console.log(res.data.message);
                  setTimeout(() => {
                    this.$router.push({path: "/"})
                  }, 1000);
    
                  // localStorage.setItem('token',res.data.data)
                    // 将登录名使用vuex传递到Home页面
                this.$store.commit('handleUserName',res.data.data.tel);
                }
    ```

  - 

### 登录页面隐藏导航栏

- 给导航栏添加v-show属性

  - ```js
    //根据当前路由设置navbar的显示与隐藏 
    <Navbar v-show="$route.path!=='/login'"/>
    ```

  - 

### 页面优化

#### 实现登录结果弹出提示框

- 登录成功,弹框提示登录成功
- 登录失败, 弹框提示登录失败
  - 为消息条绑定success 数据, 登录成功为true, 失败为false, 三目运算符判断, 给消息条赋值

#### 实现登录按钮加载





## 拼图功能的实现

### 页面搭建

#### 整体框架

- 整个页面分为两个部分, 分别是拼图部分和功能按钮部分
- 使用vuetify的网格系统, 在不同屏幕下, 两个部分的布局和宽度动态变化, 在移动端, 为上下布局, 其他视口下均为左右布局, 

#### 拼图方块动态大小

- 由于移动端宽度差异过多, 此处拼图面板只设置最大宽度max-width: 550px, 高度根据宽度自适应,
  - 遇到的问题: 在给拼图容器根据容器宽度动态设置高度时, 发现浏览器大小变化时, 高度无法动态跟随变化, 需要刷新后, 样式才变化, 
  - 解决方法, 通过搜索资料, 在GitHub上发现了一个VUE按比例设置标签高度的指令, 通过引入并使用这个指令, 实现了拼图面板与方块根据页面大小动态改变的效果

#### 方块背景图片的设置

- 实现上述拼图方块的动态改变后,  方块背景图片大小应该随着方块的宽高而动态的改变, 同时方块的背景图片位置也应该动态改变
  - 遇到的问题: 在根据方块宽度与高度设置拼图方块背景图片时, 再次出现了上述问题.经过调试后, 发现应该使用 window.onresize() 方法, 即每当视口的宽度发生变化, 都应该调用一次渲染方法, 

  - 解决方法: 在mounted中加入window.onresize事件, 在destroyed中注销window.onresize事件. 为防止引入的依赖出现不再维护, 作者删除导致依赖不存在等情况, 在这里将上述遇到的问题也改为此种解决方式.

    - ```js
      mounted() {
          // 为实现拼图大动态小自适应页面,每当视口发生改变, 重新渲染一次拼图面板的高度, 重新渲染背景图片大小
          window.onresize = () => {
            this.setHeight()
            this.imgRender()
          };
            this.render(0); //默认显示3*3拼图
          // window.addEventListener('render',this.render(0))
          this.notClick(); //游戏开始前无法操作
        },
        destroyed() {
          window.onresize = null
        }
      ```

  - 

  - 1、window.onresize事件一般放在created或者mounted生命周期中。

    2、window.onresize中的this指向的是window，不是指向vue，如果需要调用methods中的函数，需要在window.onresize事件的前面把指向vue的this赋值给其他字符，比如"_this"；或者使用箭头函数。

    3、由于window.onresize是全局事件，在其他页面改变界面时也会执行，这样可能会出现问题，需要在出这个界面时注销window.onresize事件。

    4、window.onresize说明一个问题：beforeCreate、created、beforeMount、mounted、beforeUpdate、updated中的会触发浏览器事件需要在destroyed、beforeDestory中销毁掉。



- 使用vuetify的特性, 三乘三的拼图, 每个格子占位 是 4 ,
- 为\<v-container/> 设置宽度, 保证每个格子是正方形
- 使用计算属性设置格子的高度与宽度相等
- 4\*4与5\*5的布局, 通过动态的控制格子占位实现, 4\*4的占位是 3 , 5\*5的占位栅格系统无法五分, 此处应改写部分源码
- 由于每个格子有边框, 所以要为格子设置box-sizing: border-box属性

### 基本功能实现

#### 渲染

```js
rander(index) {
      if (index === 0) {
        this.puzzles = [1, 2, 3, 4, 5, 6, 7, 8, 0];
      } else if(index === 1) {
        this.puzzles = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0];
      } else if(index === 2) {
        this.puzzles = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 0];
      }
    }
```



#### 打乱拼图

- 初始化
  
- 方块无边框,不可点击
  
- 使用Lodash JavaScript工具库
  - 遍历 array、object 和 string
  - 对值进行操作和检测
  - 创建符合功能的函数
  - 优化
    - 打乱数组后, 使用逆序奇偶性判断能否复原, 不能再次调用自身, 重新打乱,直到能够复原为止
  
- ```js
      shuffle() {
        let cells = document.querySelectorAll('.cell')
          // console.log(cells);
          for (let i = 0; i < cells.length; i++) {
            let cell = cells[i]
            console.log(cell);
            // 取消方块边框与阴影样式, 
            
            cell.style.border = '1px solid #fff'
            cell.style.boxShadow = '0px 0px 3px #333333'
            // 为0方块添加白背景色
            if (cell.innerHTML === '0') {
              cell.classList.add('cell-zero')
            }
            // 调用禁止点击函数, 使方块禁止被点击, 只有再重新打乱后才能点击
            cell.classList.remove('notClick')
          }
        this.puzzles = _.shuffle(this.puzzles);
        // this.puzzles = [5, 1, 2, 4, 9, 6, 3, 8, 13, 15, 10, 11, 14, 0, 7, 12]
        // this.puzzles = [1, 6, 2, 4, 9, 5, 3, 8, 13, 7, 0, 11, 14, 10, 15, 12]
        let Setting = {};
        switch (this.cols) {
          case 4:
            Setting = {
              originalNode: _.chunk(this.puzzles, 3),
              resultNode: [
                [1, 2, 3],
                [4, 5, 6],
                [7, 8, 0],
              ]
            };
            break;
          case 3:
            Setting = {
              originalNode: _.chunk(this.puzzles, 4),
              resultNode: [
                [1, 2, 3, 4],
                [5, 6, 7, 8],
                [9, 10, 11, 12],
                [13, 14, 15, 0],
              ]
            };
            break;
          default:
            break;
        }
        if (
          this.canReach().canReach(
            Setting.originalNode,
            Setting.resultNode
          )
        ) {
          console.log("可复原");
          console.log(this.puzzles);
        } else {
          this.isCanReach = 0
          this.snackbar = true
          setTimeout(() => {
            this.shuffle();
            this.snackbar = false
          }, 3000);
          console.log('重新打乱后的数组',this.puzzles);
        }
      },
  
  ```

- 

#### 点击和移动

- 这个地方稍微复杂一点，具体过程就是当点击某个块的时候获取点击快上下左右的值，如果空白块在点击快的左边，并且点击快不是此列的第一个，则点击块往左侧和空白块交换位置，其实是交换值。

- ```js
   clickBlock(index) {
        // console.log(index);
        let curIndex = this.puzzles[index];
        let leftIndex = this.puzzles[index - 1];
        let rightIndex = this.puzzles[index + 1];
        let topIndex = this.puzzles[index - 3];
        let bottomIndex = this.puzzles[index + 3];
        switch (this.cols) {
          case 4:
            if (leftIndex == 0 && index % 3) {
              this.$set(this.puzzles, index - 1, curIndex);
              this.$set(this.puzzles, index, 0);
            } else if (rightIndex == 0 && 2 !== index % 3) {
              this.$set(this.puzzles, index + 1, curIndex);
              this.$set(this.puzzles, index, 0);
            } else if (topIndex == 0) {
              this.$set(this.puzzles, index - 3, curIndex);
              this.$set(this.puzzles, index, 0);
            } else if (bottomIndex == 0) {
              this.$set(this.puzzles, index + 3, curIndex);
              this.$set(this.puzzles, index, 0);
            }
            break;
          case 3:
            topIndex = this.puzzles[index - 4];
            bottomIndex = this.puzzles[index + 4]
            if (leftIndex == 0 && index % 4) {
              this.$set(this.puzzles, index - 1, curIndex);
              this.$set(this.puzzles, index, 0);
            } else if (rightIndex == 0 && 3 !== index % 4) {
              this.$set(this.puzzles, index + 1, curIndex);
              this.$set(this.puzzles, index, 0);
            } else if (topIndex == 0) {
              this.$set(this.puzzles, index - 4, curIndex);
              this.$set(this.puzzles, index, 0);
            } else if (bottomIndex == 0) {
              this.$set(this.puzzles, index + 4, curIndex);
              this.$set(this.puzzles, index, 0);
            }
            
            break;
          default:
            break;
        }
    
        this.pass();
      },
  ```

- 

#### 判赢

- 过关条件
  - 最后一块是空
  
  - 前面8个是从1-8顺序排列
  
  - 4\*4与5\*5类似
  
  - ```js
    if (this.puzzles[8] === 0) {
                const newPuzzles = this.puzzles.slice(0, 8);
                console.log('newPuzzles',newPuzzles);
                const isPass = newPuzzles.every((e, i) => e === i + 1);
                console.log('isPass',isPass);
                if (isPass) {
                  setTimeout(() => {
                    passStyle()
                  }, 1000);
                }
              }
    ```
  
  - 
  
- 判赢优化

  - 自己手动拼的, 成功后弹出提示框, 上有本次获得积分, 拼图不可再次被点击, 取消边框样式

  - 自动拼图的, 完成后没有本次积分, 拼图不可再次被点击, 取消边框样式

  - 只有当再次打乱拼图后方块才能被点击

  - ```js
     pass() {
          const _this = this;
          function passStyle() {
            _this.isCanReach = 2;
            _this.snackbar = true;
            _this.notClick();
          }
          switch (this.cols) {
            case 4:
              if (this.puzzles[8] === 0) {
                const newPuzzles = this.puzzles.slice(0, 8);
                console.log("newPuzzles", newPuzzles);
                const isPass = newPuzzles.every((e, i) => e === i + 1);
                console.log("isPass", isPass);
                if (isPass) {
                  setTimeout(() => {
                    passStyle();
                  }, 1000);
                }
              }
              this.isCanReach = 0;
              break;
            case 3:
              if (this.puzzles[15] === "0" || this.puzzles[15] === 0) {
                const newPuzzles = this.puzzles.slice(0, 15);
                const isPass = newPuzzles.every((e, i) => e === i + 1);
                if (isPass) {
                  setTimeout(() => {
                    passStyle();
                  }, 1000);
                }
              }
              break;
            case 0:
              if (this.puzzles[24] === "0" || this.puzzles[24] === 0) {
                const newPuzzles = this.puzzles.slice(0, 24);
                const isPass = newPuzzles.every((e, i) => e === i + 1);
                if (isPass) {
                  setTimeout(() => {
                    passStyle();
                  }, 1000);
                }
              }
              break;
            default:
              break;
          }
        },
    ```

  - 

  

#### 人工智能复原拼图

##### 3*3N数码问题,八数码问题的求解

- 判断八数码问题是否有解（其实就是判断该拼图是否可以还原）

- 将有解的数组传给后端, 使用A*算法求解,返回移动步骤

  - 有解数组格式

    - 以逗号分隔的字符串

    - ```js
      //使用lodash库
      
      ```

    - 

- 获取移动步骤,调用点击方法,完成拼图

  - 此处涉及for循环嵌套延时器问题, 间隔相同时间调用点击事件

  - ```js
    for (let i = 0; i < res.data.data.stepNumber; i++) {
                    (function () {//将延时器整个的包裹在一个子执行函数中
                      setTimeout(() => {
                        console.log(res.data.data.tabbingOrder[i]);
                        _this.clickBlock(res.data.data.tabbingOrder[i]) 
                      }, i * 500);//想要每隔0.5秒调用一次，而不是同时调用，要将参数传进时间中
                    })(i);//把每个循环中的 i 在被回收之前直接传入到自执行函数中，这样就可以避免被回收
                  }
    
    ```

  - 

### 游戏等级分类

#### 4\*4拼图的页面展示

- 创建菜单按钮,为按钮添加事件levelChoose(index),  0 表示初级, 1 表示中级, 2 表示高级

- 根据传入的参数, 更改方块占据的宽度, 从而改变每行是3个还是4个方块, 

- 根据传入的参数, 更改数组的内容, 初级为0~9, 中级为 0~15

- 根据传入的参数, 更改方块的高度, *==目前存在第一次调用失效问题==*
  
  - 应先移除3\*3的高度, 否则会先渲染3\*3的高度样式
  
- 在渲染方块值函数中传入参数index, 默认 为 0, 即 3\*3拼图

- ```js
  levelChoose(index) {
        const cells = document.querySelectorAll('.cell')
        if (index === 0) {
          this.cols = 4
          this.rander(index)
        } else if (index === 1) {
          this.cols = 3
          this.rander(index)
          console.log(this.puzzles);
          for (let i = 0; i < cells.length; i++) {
            cells[i].classList.remove('cell-3-height')
            cells[i].classList.add('cell-4-height')
          }
        } else {
          this.cols = 2.5
          this.rander(index)
        }
      },
  ```

- 

#### 4\*4拼图点击方块

- 通过cols变量, 判断当前是几乘几的拼图,更改判断条件

#### 4*4判赢

- 通过cols变量, 判断当前是几乘几的拼图, 更改判断条件

```js
pass() {
      switch (this.cols) {
        case 4:
          if (this.puzzles[8] === 0) {
            const newPuzzles = this.puzzles.slice(0, 8);
            console.log('newPuzzles',newPuzzles);
            const isPass = newPuzzles.every((e, i) => e === i + 1);
            console.log('isPass',isPass);
            if (isPass) {
              setTimeout(() => {
                passStyle()
              }, 1000);
            }
          }
          this.isCanReach = 0
          break;
        case 3:
          if (this.puzzles[15] === "0" || this.puzzles[15] === 0) {
            const newPuzzles = this.puzzles.slice(0, 15);
            const isPass = newPuzzles.every((e, i) => e === i + 1);
            if (isPass) {
              alert("666！");
            }
          }
          
          break;
        default:
          break;
      }
    },
  },
```

#### 5\*5的实现

- 栅格系统不支持5等分

- 根据源码更改需要的宽度占比, 实现5*5布局

- ```css
  .level-5 {
    min-height: 1px;
    flex: 0 0 20%;
    max-width: 20%;
    float: left;
  }
  ```

- 在选择5\*5后, 应删除栅格系统的类名, 添加自定义的样式 level-5

- ```js
  setLevel5() {
        this.$nextTick(() => {
          console.log(this.puzzles);
          let cells = document.querySelectorAll('.cell')
          console.log(cells);
          for (let i = 0; i < cells.length; i++) {
            // console.log('cells');
            cells[i].classList.toggle('col-4',false)
            cells[i].classList.toggle('col-3',false)
            cells[i].classList.toggle('col-0',false)
            cells[i].classList.add('level-5')
            console.log('类名', cells[i].classList);
          }
        })
      },
  ```

- 

### 优化-判断拼图是否有解

- 由于打乱拼图顺序使用的是随机数, 所以会出现拼图无解的情况, 每次打乱后应判断拼图是否有解, 判断方法如下

- ```js
  /*
              最终的判断方法是判断两个矩阵的 ：
              逆序数 + “0”的行数 + “0”的列数的和的奇偶性是否相同
              如果相同则，则可以还原拼图，不相同则不可还原。
            */
     // 判断拼图是否能够复原
      canReach() {
        return {
          // 是否可达
          canReach(originalNode, resultNode) {
            // console.log('源数组的行数',originalNode.length);
            // console.log('源数组0的位置:',_.indexOf(_.flattenDeep(originalNode), 0));
  
            // console.log('源数组0所在的行数:',Math.ceil((_.indexOf(_.flattenDeep(originalNode), 0)+1)/originalNode.length));
  
            
            let OLRow,OLCol
            // let OLCol = Math.ceil((_.indexOf(_.flattenDeep(originalNode), 0)+1)%originalNode.length)
            
            let RLRow = resultNode.length-1
            console.log('目标零的位置',RLRow);
            for (let i = 0; i < originalNode.length; i++) {
              let tmp = originalNode[i]
              console.log(tmp);
              for (let j = 0; j < tmp.length; j++) {
                if (originalNode[i][j] === 0) {
                  OLRow = i
                  OLCol = j
                  console.log('源数组0所在的行列数',OLRow,OLCol);
                }
              }
            }
            originalNode = originalNode.toString().split(",");
            resultNode = resultNode.toString().split(",");
            
            /*
              最终的判断方法是判断两个矩阵的 ：
              逆序数 + “0”的行数 + “0”的列数的和的奇偶性是否相同
              如果相同则，则可以还原拼图，不相同则不可还原。
            */
            let originalRON = this.odevity(originalNode) + OLRow + OLCol
            let resultRON = this.odevity(resultNode) + RLRow + RLRow
  
            if ( originalRON % 2 === resultRON % 2 ){
              return true
            } else {
              return false
            }
            
            /*
              当N为奇数时， 当两个N数码的逆序数 奇偶性相同时，可以互达，否则不行；
  
              当N为偶数时，当两个N数码的奇偶性相同的话，那么两个N数码中的0所在行的差值 k，k也必须是偶数时，才能互达；
                        当两个N数码的奇偶性不同时，那么两个N数码中的0所在行的差值 k，k也必须是奇数时，才能互达；
            */
            // if (RLRow % 2) {//N是奇数
              
            //   if (this.odevity(originalNode) === this.odevity(resultNode)) {
            //     return true;
            //   } else {
            //     return false;
            //   }
            // } else {//N是偶数
            //   console.log('N是偶数');
            //   if (this.odevity(originalNode) === this.odevity(resultNode)) {//奇偶性相同
            //     console.log('奇偶性相同');
            //     if (Math.abs(OLRow - RLRow) % 2) {//K是奇数
            //       return false
            //     } else {
            //       return true
            //     }
            //   } else {//奇偶性不同
            //     if (Math.abs(OLRow - RLRow) % 2) {//K是奇数
            //       return true
            //     } else {return false}
            //   }
            // }
            
  
            
          },
          // 求逆序奇偶性
          odevity(node) {
            var num = 0;//先介绍一下逆序数：在一列数中，每个数前面有几个比自己大的数，就是这个数的逆序数，这一列数的逆序数就是这一列数的逆序数的总和；
            //node.splice(node.indexOf('0'), 1);//在算N数码的逆序数时，不把0算入在内；
            node.forEach(function (item, index) {
              for (var i = 0; i < index; i++) {
                //if (node[i] != 0) {//在算N数码的逆序数时，不把0算入在内；
                  if (node[i] > item) {
                    num++;
                 // }
                }
              }
            });
            // console.log('逆序数',num);
            return num
          }
        };
      },
  ```

- 

### 优化-游戏开始前不允许点击

- 添加封装canClick()与notClick()函数

- 游戏开始前, 

  - 不允许点击拼图面板,

  -  方块无边框,

  -  0方块无白色背景

  - 自动拼图按钮无效

  - 保存进度按钮无效

  - ```js
    notClick() {
          this.$nextTick(() => {
            let cells = document.querySelectorAll(".cell");
            let btnAutoPlay = document.querySelector('#btnAutoPlay')
            let btnSave = document.querySelector('#btnSave')
            // console.log(cells);
            for (let i = 0; i < cells.length; i++) {
              let cell = cells[i];
              // console.log(cell);
              // 取消方块边框与阴影样式, 取消白块背景色
              cell.style.border = "none";
              cell.style.boxShadow = "none";
              cell.style.backgroundImage = "url(" + this.imgUrl + ")";
              cell.classList.remove("cell-zero");
              // 调用禁止点击函数, 使方块禁止被点击, 只有再重新打乱后才能点击
              cell.classList.add("notClick");
            }
            btnAutoPlay.classList.add("notClick")
            btnSave.classList.add("notClick")
          });
        },// 禁止点击, 取消拼图时的样式
        notClick() {
          this.$nextTick(() => {
            let cells = document.querySelectorAll('.cell')
            // console.log(cells);
            for (let i = 0; i < cells.length; i++) {
              let cell = cells[i]
              // console.log(cell);
              // 取消方块边框与阴影样式, 取消白块背景色
              cell.style.border = 'none'
              cell.style.boxShadow = 'none'
              cell.classList.remove('cell-zero')
              // 调用禁止点击函数, 使方块禁止被点击, 只有再重新打乱后才能点击
              cell.classList.add('notClick')
            }
          })
        },
    ```

  - 

- 游戏开始后, 

  -  为方块添加边框,

  -  0方块变为白色

  - 允许点击拼图面板

  - 允许保存进度

  - 允许自动拼图

  - ```js
     
        // 允许点击, 添加拼图时的样式
       canClick() {
          this.$nextTick(() => {
            let cells = document.querySelectorAll(".cell");
            let btnAutoPlay = document.querySelector('#btnAutoPlay')
            let btnSave = document.querySelector('#btnSave')
            btnAutoPlay.classList.remove("notClick")
            btnSave.classList.remove("notClick")
            // console.log(cells);
            for (let i = 0; i < cells.length; i++) {
              let cell = cells[i];
              // console.log(cell);
    
              cell.style.border = "1px solid #fff";
              cell.style.boxShadow = "0px 0px 3px #333333";
              // 为0方块添加白背景色
              if (cell.innerHTML === "0") {
                cell.classList.add("cell-zero");
                cell.style.backgroundImage = "none";
              }
              // cell.style.textIndent = '-999px'
              // 调用禁止点击函数, 使方块禁止被点击, 只有再重新打乱后才能点击
              cell.classList.remove("notClick");
            }
          });
        },
    ```

- 遇到的问题

  - 在进行难度选择后, 发现4\*4与6\*6拼图的方块只有前九个被更改了样式, 只有再次选择同样的难度后, 才成功渲染样式, 经过调试发现是在新增节点后，执行DOM操作获取节点时，取到的仍是之前的结构，新增的节点并未获取到。原因是vue使用的虚拟DOM，使得页面虽然已经渲染出来，但在Vue实例中仍处在在虚拟DOM中，无法获取。
  - 解决方法: **使用Vue.nextTick** ,在下次DOM更新循环结束之后执行延迟回调, 在修改数据之后立即使用这个方法, 获取更新后的DOM

### 优化-封装节点函数, 用于打乱, 自动拼图, 图片渲染

- ```js
   setting() {
        let Setting = {};
        switch (this.cols) {
          case 4:
            Setting = {
              originalNode: _.chunk(this.puzzles, 3),
              resultNode: [
                [1, 2, 3],
                [4, 5, 6],
                [7, 8, 0],
              ]
            };
            break;
          case 3:
            Setting = {
              originalNode: _.chunk(this.puzzles, 4),
              resultNode: [
                [1, 2, 3, 4],
                [5, 6, 7, 8],
                [9, 10, 11, 12],
                [13, 14, 15, 0],
              ]
            };
            break;
          case 2:
          Setting = {
            originalNode: _.chunk(this.puzzles, 6),
            resultNode: [
              [1, 2, 3, 4, 5, 6],
              [7, 8, 9, 10, 11, 12],
              [13, 14, 15, 16, 17, 18],
              [19, 20, 21, 22, 23, 24],
              [25, 26, 27, 28, 29, 30],
              [31, 32, 33, 34, 35, 0]
            ]
          };
            break;
          default:
            break;
        }
        return Setting
      },
  ```

- 

### 图片切割与绘制

- 将传入的图片切割为正方形
- 将引入的图片输出为自定义的宽高, 此处自定义宽高指拼图面板的宽度与高度

#### 为cell添加背景图片

- 将方块根据等级转换为 N\*N 的二维数组

- 双重循环遍历二维数组, 为每个元素设置背景图片, 背景图片大小, 背景图片位置

  - 3\*3方块背景图位置,

    - [0px, 0px], [-100px, 0px], [-200px, 0px]
    - [0px, -100px], [ -100px,  -100px], [ -200px,  -100px]
    - [0px, -200px], [ -100px,  -200px], [ -200px,  -200px]

  - ```js
     imgRender(index) {
          this.$nextTick(() => {
            let cells = document.querySelectorAll('.cell')
            // console.log(cells);
            let size
            switch (index) {
              case 0:
                size = 3
                break;
              case 1:
                size = 4
                break;
              case 2:
                size = 5
                break;
              default:
                break;
            }
            let cellsArr = _.chunk(cells,size)
            // console.log(cellsArr.length);
            for (let i = 0; i < size; i++) {
              for (let j = 0; j < size; j++) {
                // console.log(i, j);
                cellsArr[i][j].style.backgroundImage = 'url(' + this.imgUrl +')' 
                cellsArr[i][j].style.backgroundSize = '300px 300px'
                cellsArr[i][j].style.backgroundPosition = -j * 300/size + 'px ' + -i * 300/size + 'px' 
                console.log(cellsArr[i][j].style.backgroundSize,cellsArr[i][j].style.backgroundPosition);
              }
            }
            // let cellArr = [].slice.call(cells)
            // console.log(cellArr);
            
          })
        },
    ```

- 遇到的问题

  - 在为方块添加背景图片时, 发现路径正确的情况下,获取不到图片

  - 调试时查看图片路径, 发现路径如下图, 网页把根域名作为相对路径的根目录了，这样解析出来的路径当然找不到图片资源。这里还有一个重点：动态添加src被当做静态资源处理了，没有进行编译。如果是 <img src="../assets/img/004.png" alt="" 这样的静态路径，vue大部分情况会把图片处理成base64位，这样就不存在路径问题了...

  - ![image-20210124095836662](毕设 - 拼图游戏.assets/image-20210124095836662.png)

  - 解决方法 : 在data 里面require 图片的相对路径

    - ```js
      data: () => ({
          imgUrl: require('../assets/img/004.jpg')
        }),
      ```

    - require是node的模块化引入的规范，通过require引入图片的方式可以将图片编译成base64，这样也不存在路径问题...但是问题来了...转成baes64对图片大小是有限制的，先看webpack.base.confit.js中的一段代码：

      ![img](https://images2018.cnblogs.com/blog/1062623/201808/1062623-20180824171129525-821781132.png)

      这里的limit是个坎，图片小于这个限制时会被转成base64，大于这个限制会被当成模块被url-loader处理，加入hash值，变成一个绝对路径...结合第二种方案的坑，这时的图片也有可能找不到...因此，可以适当的把这个限制调大点，然后重新npm run dev...

### 选择图片

由于选择图片有三种方式, 将此功能单独封装为一个组件ChooseImg.vue, 返回图片地址给Home.vue

#### 页面搭建

- 点击选择图片按钮, 弹出对话框, 有三个选项, 分别是拍照, 相册, 默认图片, 根据需求选择
  - 点击拍照选项, 显示拍照遮罩层, 进行拍照操作, 遮罩层隐藏
  - 点击相册选项, 打开相册文件, 选择图片,对话框隐藏
  - 点击默认图片选项,对话框隐藏

#### PC端拍照

- 拍照功能通过 H5新媒体接口 navigator.mediaDevices.getUserMedia()实现, 这个方法会提示用户是否允许媒体输入,(媒体输入主要包括相机,视频采集设备,屏幕共享服务,麦克风,A/D转换器等)

- ```js
     cameraImg() {
        this.videoModal = true;
        let constraints = {
          video: {
            width: document.querySelector(".video-wrap").offsetWidth,
            height: document.querySelector(".video-wrap").offsetWidth,
          },
          audio: true,
        };
        // console.log(constraints);
        // 此处等待UI渲染进程结束，再执行js逻辑线程
        setTimeout(() => {
          let promise = navigator.mediaDevices.getUserMedia(constraints);
        
          let video = document.querySelector("#video");
          // console.log(video);
          promise
            .then(function (MediaStream) {
              video.srcObject = MediaStream;
              video.play();
            })
            .catch(function (PermissionDeniedError) {
              console.log(PermissionDeniedError);
            });
        }, 500);
        
        /*
          这里介绍新的方法:H5新媒体接口 navigator.mediaDevices.getUserMedia()
          这个方法会提示用户是否允许媒体输入,(媒体输入主要包括相机,视频采集设备,屏幕共享服务,麦克风,A/D转换器等)
          返回的是一个Promise对象。
          如果用户同意使用权限,则会将 MediaStream对象作为resolve()的参数传给then()
          如果用户拒绝使用权限,或者请求的媒体资源不可用,则会将 PermissionDeniedError作为reject()的参数传给catch()
          */
      },
      takePhoto() {
        var video = document.getElementById("video");
        var canvas = document.getElementById("canvas"),
          ctx = canvas.getContext("2d"),
          CHeight = video.clientHeight, //获取屏幕大小让canvas自适应
          CWidth = video.clientWidth;
        canvas.width = CWidth;
        canvas.height = CHeight;
        //localMediaStream 在data里定义一个{}
        ctx.drawImage(video, 0, 0, CWidth, CHeight);
        var dataURL = canvas.toDataURL("image/jpeg"); //dataURL = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAA'
        console.log(dataURL);
        this.imgUrl = dataURL;
        this.$emit('imgUrl',this.imgUrl)
      },
    },
  ```

#### 优化-拍照

- 玩家执行完拍照操作后, 应显示'确认', '重新拍照' 按钮供用户选择, 

  - 隐藏video标签, 展示canvas标签, 确认按钮, 重新拍照按钮
  - 点击确认, 隐藏遮罩层, 关闭摄像头
  - 点击'重新拍照', 隐藏按钮, canvas, 展示video,重新拍照

- 添加打开相册按钮

- 添加关闭按钮

- 美化页面

- 解决镜像问题

  - 使用CSS将video与canvas镜像翻转

#### 手机端拍照

- 类似从相册选择, 只是需要调用一下手机的相机功能,
- 拍照后, 获取拍照的文件, 传给vue-cropper组件, 显示拍照的图片, 并进行裁剪

#### 从相册选择

- 打开相册文件, 选择照片, 裁剪
- 使用file类型的input标签, 打开文件夹或者手机相册
- 选择图片后, 使用vue-cropper组件实现图片的裁剪
- 获取裁剪区域, 将生成的base64地址传给父组件的图片地址属性

#### 默认图片

- 直接返回保存在资源中的图片路径
- 此处返回路径直接在子组件中使用require获取图片相对路径即可

#### 父组件接收

- 父组件接收到子组件传回来的图片地址后,通过当前游戏等级重新渲染拼图面板
- 调用notClick()方法, 选择图片后应回到游戏初始状态, 重新打乱

#### 图片处理

- 压缩图片
- 转为base64
- 

### 进度保存与读取

#### 保存进度

- 点击保存进度按钮, 弹出对话框
  - 名称[默认显示游戏等级-时间], 
  - 用户可自定义名称
  - 点击保存, 将名称, 保存时间, 拼图难度, 数组序列,拼图图片保存到当前用户的游戏进度
- 页面搭建
  - 点击保存进度按钮, 弹出对话框
  - 对话框中写入表单 , title 标题字段
  - 点击对话框中的保存进度按钮, 将title, 当前日期, 当前数组,当前游戏等级, 当前图片 [file], 当前用户传至后台 
  - 保存成功后, 弹出提示框, 提示用户保存成功
- 遇到的问题
  - 本地图片地址是相对路径, 拍照,相册的图片是base64格式, 需要把本地图片也转为base64, 在转换过程中用到image.onload异步函数,  造成地址还未转换完成就执行了下一步转换为blob格式
  - 解决方法: 将转换base64格式的函数以promise返回,  判断当前图片地址格式, 若当前地址为base64, 转换为blob格式, 加入formdata对象, 若不是base64, 使用promise的then()方法, 获取base64, 转换为blob ,加入formdata对象 
  - 

#### 读取进度

- 点击读取进度按钮, 弹出保存的进度列表,
  - 请求游戏进度列表
    - 参数:  当前用户
    - 请求数据: title,游戏等级,  保存时间
  - 用户根据需求选择保存的游戏进度
    - 请求参数: 当前用户, title, 保存时间
    - 请求数据: 数组序列, 图片, 游戏等级
- 用到的方法
  - 打乱函数, 图片渲染

### 查看原图

- 点击查看原图按钮, 弹出当前拼图的原图
- 使用对话框组件 , 在组件中动态引入图片即可

### 显示/隐藏数字

- 若当前方块显示数字, 按钮内容为 '隐藏数字', 点击按钮, 数字隐藏
- 若当前方块未显示数字, 按钮内容为 '显示数字', 点击按钮, 数字显示

- 实现方法

  - 定义变量 isShowNum = false

  - 创建函数showNumber(), 点击按钮对isShowNum取反, 

  - 根据isShowNum值动态设置按钮内容, 动态为cell添加样式 textIndent = '0px', textIndent = '-9999px'

  - ```html
    <v-btn @click="showNumber()" outlined> {{ isShowNum ? "隐藏序号" : "显示序号"}} </v-btn>
    ```

  - ```js
     showNumber() {
          this.isShowNum = ! this.isShowNum
          console.log(this.isShowNum);
          let cells = document.querySelectorAll('.cell')
          for (let i = 0; i < cells.length; i++) {
            if (this.isShowNum) {
              cells[i].style.textIndent = '0px'
              } else {
              cells[i].style.textIndent = '-9999px'
            }
          }
        }
    ```

  - 

### 优化 - 打乱函数

- 由于随机数打乱会生成不可解的拼图, 且使用逆序奇偶性判断是否可解存在偶然性, 所以打乱拼图由后端完成, 直接生成可解拼图, 前端通过拼图等级向后端请求打乱后的拼图数组并进行页面渲染

  ```js
  shuffle() {
        this.canClick()
        // 向后台传入当前游戏等级, 请求打乱的序列
        let level
          
          switch (this.cols) {
            case 4:
              level = 3
              break;
            case 3:
              level = 4
              break;
            case 0:
              level = 5
              break;
          
            default:
              break;
          }
        console.log(level);
        // 获取后台传入的数组序列
        
        console.log("获取后台传入的数组序列");
        this.$axios.post('http://a.wpengsen.cn:8989/puzzle/generatedData',qs.stringify({num: level}))
        .then(res=>{
            console.log(res)
            // 如果请求成功,执行点击方法,自动复原
            if (res.status === 200) {
              // console.log(res.data.data);
              this.puzzles = res.data.data
              
            } else {
              //弹出提示框,请求有误,重新尝试
              console.log('请求有误');
            }
        })
      },
  ```

### 优化 - 自动拼图

- 前端通过拼图数组与拼图等级向后端申请正确的拼图序列

- 得到拼图序列后,  通过拼图序列, for循环执行点击方法, 并使用定时器每0.5s移动一次. 

- ```js
  autoPlay() {
        let level;
        switch (this.cols) {
          case 4:
            level = 3;
            break;
          case 3:
            level = 4;
            break;
          case 0:
            level = 5;
            break;
  
          default:
            break;
        }
        console.log("获取后台步骤数据");
        const _this = this;
        this.$axios
          .post(
            "http://a.wpengsen.cn:8989/puzzle/automaticCalculation",
            qs.stringify({ node: _.join(this.puzzles, ","), num: level })
          )
          .then((res) => {
            console.log(res);
            // 如果请求成功,执行点击方法,自动复原
            if (res.status === 200) {
              //通过步骤,for循环调用点击方法
              console.log(res.data.data.simpleProcess);
              let step = res.data.data.simpleProcess;
              for (let i = 0; i < step.length; i++) {
                (function () {
                  //将延时器整个的包裹在一个子执行函数中
                  setTimeout(() => {
                    console.log(step[i]);
                    _this.clickBlock(step[i]);
                  }, i * 500); //想要每隔0.5秒调用一次，而不是同时调用，要将参数传进时间中
                })(i); //把每个循环中的 i 在被回收之前直接传入到自执行函数中，这样就可以避免被回收
              }
            } else {
              //弹出提示框,请求有误,重新尝试
              console.log("请求有误");
            }
          });
  
        // let Setting = this.setting()
        // if (
        //   this.canReach().canReach(
        //     Setting.originalNode,
        //     Setting.resultNode
        //   )
        // ) {
        //   // 可复原,弹出提示框
        //   this.isCanReach = 1
        //   this.snackbar = true
        //   console.log("可复原");
        //   let originalNodeStr =_.join(this.puzzles, ",")
        //   const _this = this
        //   console.log(originalNodeStr);
        //   //传递源节点, 获取点击步骤
        //   console.log("获取后台步骤数据");
        //   this.$axios.post('http://a.wpengsen.cn:8989/puzzle/automaticCalculation',qs.stringify({node:originalNodeStr,num:Setting.originalNode.length}))
        //   .then(res=>{
        //       console.log(res)
        //       // 如果请求成功,执行点击方法,自动复原
        //       if (res.status === 200) {
        //         //通过步骤,for循环调用点击方法
        //         for (let i = 0; i < res.data.data.stepNumber; i++) {
        //           (function () {//将延时器整个的包裹在一个子执行函数中
        //             setTimeout(() => {
        //               console.log(res.data.data.tabbingOrder[i]);
        //               _this.clickBlock(res.data.data.tabbingOrder[i])
        //             }, i * 500);//想要每隔0.5秒调用一次，而不是同时调用，要将参数传进时间中
        //           })(i);//把每个循环中的 i 在被回收之前直接传入到自执行函数中，这样就可以避免被回收
        //         }
        //       }else {
        //         //弹出提示框,请求有误,重新尝试
        //         console.log('请求有误');
        //       }
        //   })
        //   this.isCanReach = 0
        //   this.snackbar = false
        // } else {
        //   // this.isCanReach = 0
        //   this.snackbar = true
        //   setTimeout(() => {
        //     this.shuffle();
        //   }, 3000);
        //   console.log('重新打乱后的数组',this.puzzles);
        //   setTimeout(() => {
        //     this.autoPlay();
        //     this.snackbar = false
        //   }, 5000);
        // }
      },
  ```

- 

- 优化页面
  - 重新打乱提示动画
    - ![image-20210122235110457](毕设 - 拼图游戏.assets/image-20210122235110457.png)
  - 登录页面优化
    - ![image-20210122235000177](毕设 - 拼图游戏.assets/image-20210122235000177.png)
  - 排名页面
  - 步数项,积分项
  - 菜单栏优化
    - 用户固定头像
    - 版权声明
    - ![image-20210122235140351](毕设 - 拼图游戏.assets/image-20210122235140351.png)
- 选择图片功能



### 积分计算

注册: + 100 分

初级: + 2 分

中级: + 5 分

高级: + 10 分

成功完成拼图后, 提示用户完成拼图, 并显示所得积分, 将积分传给后端添加给当前用户

设置变量isAuto, 使用自动拼图完成的,不计分



积分展示放在侧边栏



### 查看排名

调取积分前100名用户, 展示用户头像, 账号, 积分

### 用户头像

#### 默认头像

- 用户第一次注册登录, 使用默认头像
- 登录成功后获取用户信息, 若头像信息为空, 则使用默认头像, 否则加载用户设置的头像

#### 更换头像

- 使用vue-cropper组件更换用户头像
- 实现步骤
  - 点击头像, 显示遮罩层, 显示当前头像, 修改头像按钮
  - 点击修改头像按钮, 选择图片, 调用vue-cropper
  - 裁剪头像, 本地展示, 上传服务器

### 优化 - vue-cropper组件

- 有两处用到了vue-cropper, 考虑封装为一个组件, 进行调用



## 在手机调试项目

- 将电脑与手机置于同一无线网络下
- 启动项目
- 关闭电脑防火墙
- 将项目地址localhost部分改为电脑IP地址, 手机访问此网址即可
- 注: 只有在访问localhost时, 才可调用电脑的摄像头



### 书

- 像哲学家一样生活
- 反脆弱
- 被讨厌的勇气
- 第二曲线
- 中国居民膳食指南